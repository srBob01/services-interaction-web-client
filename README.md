# Пример синхронного и асинхронного REST-взаимодействия с помощью WebClient между микросервисами

## Описание проекта

Этот проект демонстрирует использование **Spring WebClient** для взаимодействия с REST API. Реализованы два подхода:

1. **Синхронный клиент**: блокирует поток до получения ответа.
2. **Асинхронный клиент**: позволяет продолжать выполнение программы, обрабатывая ответ через callback.

---

## Как это работает

1. **Серверная часть**:
    - Сервер эмулирует работу API, которое отвечает с задержкой (3 секунды).

2. **Клиентская часть**:
    - Синхронный клиент отправляет запрос и ожидает ответа, блокируя выполнение потока.
    - Асинхронный клиент отправляет запрос, продолжает выполнение и обрабатывает ответ через callback, когда он становится доступным.

3. **Вывод в консоль**:
    - Сравнение работы двух подходов отображается в логах.

---

## Пример кода: Синхронный и Асинхронный подходы

### Синхронный клиент

```java
public void fetchData() {
    System.out.println("Sending synchronous request...");
    String response = webClient.get()
            .uri("/api/data")
            .retrieve()
            .bodyToMono(String.class)
            .block(); // Блокирующий вызов
    System.out.println("Response: " + response);
}
```

- Вызов `.block()` останавливает выполнение программы до получения ответа.
- Подходит для простых задач, где блокировка потока не критична.

### Асинхронный клиент с callback

```java
public void fetchData() {
    System.out.println("Sending asynchronous request...");

    Mono<String> responseMono = webClient.get()
            .uri("/api/data")
            .retrieve()
            .bodyToMono(String.class);

    responseMono.subscribe(
        response -> {
            System.out.println("Response received: " + response);
        },
        error -> {
            System.err.println("Error occurred: " + error.getMessage());
        },
        () -> {
            System.out.println("Request completed.");
        }
    );

    System.out.println("Request sent. Waiting for response asynchronously...");
}
```

- Используется метод `.subscribe()`, который принимает три callback-функции:
    - **Первый параметр**: обработка успешного ответа.
    - **Второй параметр**: обработка ошибок.
    - **Третий параметр**: действие при завершении.
- Поток не блокируется, запрос обрабатывается параллельно.

---

## Пример работы

### Консольный вывод

1. **Синхронный клиент**:
   ```
   Sending synchronous request...
   Response: {"message": "Hello from Server!"}
   ```

2. **Асинхронный клиент**:
   ```
   Sending asynchronous request...
   Request sent. Waiting for response asynchronously...
   Response received: {"message": "Hello from Server!"}
   Request completed.
   ```

---

## Преимущества

1. **Синхронный подход**:
    - Простота в реализации.
    - Удобен для небольших задач без высокой нагрузки.

2. **Асинхронный подход**:
    - Позволяет обрабатывать множество запросов одновременно.
    - Потоки не блокируются, что увеличивает производительность.

---

## Недостатки

1. **Синхронный подход**:
    - Блокирует выполнение потока.
    - Может вызывать проблемы при высокой нагрузке.

2. **Асинхронный подход**:
    - Сложнее в реализации и отладке.
    - Требует управления подписками (callback'ами).